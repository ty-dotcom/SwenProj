(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * The symbol used as a key on message objects to store the message type.
 *
 * Note that this is an experimental feature - it is here to stay, but
 * implementation details may change without notice.
 */ __turbopack_context__.s([
    "MESSAGE_TYPE",
    ()=>MESSAGE_TYPE
]);
const MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Converts snake_case to lowerCamelCase.
 *
 * Should behave like protoc:
 * https://github.com/protocolbuffers/protobuf/blob/e8ae137c96444ea313485ed1118c5e43b2099cf1/src/google/protobuf/compiler/java/java_helpers.cc#L118
 */ __turbopack_context__.s([
    "lowerCamelCase",
    ()=>lowerCamelCase
]);
function lowerCamelCase(snakeCase) {
    let capNext = false;
    const sb = [];
    for(let i = 0; i < snakeCase.length; i++){
        let next = snakeCase.charAt(i);
        if (next == '_') {
            capNext = true;
        } else if (/\d/.test(next)) {
            sb.push(next);
            capNext = true;
        } else if (capNext) {
            sb.push(next.toUpperCase());
            capNext = false;
        } else if (i == 0) {
            sb.push(next.toLowerCase());
        } else {
            sb.push(next);
        }
    }
    return sb.join('');
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "LongType",
    ()=>LongType,
    "RepeatType",
    ()=>RepeatType,
    "ScalarType",
    ()=>ScalarType,
    "normalizeFieldInfo",
    ()=>normalizeFieldInfo,
    "readFieldOption",
    ()=>readFieldOption,
    "readFieldOptions",
    ()=>readFieldOptions,
    "readMessageOption",
    ()=>readMessageOption
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$lower$2d$camel$2d$case$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js [app-client] (ecmascript)");
;
var ScalarType;
(function(ScalarType) {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    ScalarType[ScalarType["DOUBLE"] = 1] = "DOUBLE";
    ScalarType[ScalarType["FLOAT"] = 2] = "FLOAT";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    ScalarType[ScalarType["INT64"] = 3] = "INT64";
    ScalarType[ScalarType["UINT64"] = 4] = "UINT64";
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    ScalarType[ScalarType["INT32"] = 5] = "INT32";
    ScalarType[ScalarType["FIXED64"] = 6] = "FIXED64";
    ScalarType[ScalarType["FIXED32"] = 7] = "FIXED32";
    ScalarType[ScalarType["BOOL"] = 8] = "BOOL";
    ScalarType[ScalarType["STRING"] = 9] = "STRING";
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    // TYPE_GROUP = 10,
    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.
    // New in version 2.
    ScalarType[ScalarType["BYTES"] = 12] = "BYTES";
    ScalarType[ScalarType["UINT32"] = 13] = "UINT32";
    // TYPE_ENUM = 14,
    ScalarType[ScalarType["SFIXED32"] = 15] = "SFIXED32";
    ScalarType[ScalarType["SFIXED64"] = 16] = "SFIXED64";
    ScalarType[ScalarType["SINT32"] = 17] = "SINT32";
    ScalarType[ScalarType["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType) {
    /**
     * Use JavaScript `bigint`.
     *
     * Field option `[jstype = JS_NORMAL]`.
     */ LongType[LongType["BIGINT"] = 0] = "BIGINT";
    /**
     * Use JavaScript `string`.
     *
     * Field option `[jstype = JS_STRING]`.
     */ LongType[LongType["STRING"] = 1] = "STRING";
    /**
     * Use JavaScript `number`.
     *
     * Large values will loose precision.
     *
     * Field option `[jstype = JS_NUMBER]`.
     */ LongType[LongType["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
var RepeatType;
(function(RepeatType) {
    /**
     * The field is not repeated.
     */ RepeatType[RepeatType["NO"] = 0] = "NO";
    /**
     * The field is repeated and should be packed.
     * Invalid for `bytes` and `string`, they cannot be packed.
     */ RepeatType[RepeatType["PACKED"] = 1] = "PACKED";
    /**
     * The field is repeated but should not be packed.
     * The only valid repeat type for repeated `bytes` and `string`.
     */ RepeatType[RepeatType["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
function normalizeFieldInfo(field) {
    var _a, _b, _c, _d;
    field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$lower$2d$camel$2d$case$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lowerCamelCase"])(field.name);
    field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$lower$2d$camel$2d$case$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lowerCamelCase"])(field.name);
    field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
    field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
    return field;
}
function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i)=>m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;
}
function readFieldOption(messageType, fieldName, extensionName, extensionType) {
    var _a;
    const options = (_a = messageType.fields.find((m, i)=>m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    if (!options) {
        return undefined;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
        return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
function readMessageOption(messageType, extensionName, extensionType) {
    const options = messageType.options;
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
        return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/oneof.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Is the given value a valid oneof group?
 *
 * We represent protobuf `oneof` as algebraic data types (ADT) in generated
 * code. But when working with messages of unknown type, the ADT does not
 * help us.
 *
 * This type guard checks if the given object adheres to the ADT rules, which
 * are as follows:
 *
 * 1) Must be an object.
 *
 * 2) Must have a "oneofKind" discriminator property.
 *
 * 3) If "oneofKind" is `undefined`, no member field is selected. The object
 * must not have any other properties.
 *
 * 4) If "oneofKind" is a `string`, the member field with this name is
 * selected.
 *
 * 5) If a member field is selected, the object must have a second property
 * with this name. The property must not be `undefined`.
 *
 * 6) No extra properties are allowed. The object has either one property
 * (no selection) or two properties (selection).
 *
 */ __turbopack_context__.s([
    "clearOneofValue",
    ()=>clearOneofValue,
    "getOneofValue",
    ()=>getOneofValue,
    "getSelectedOneofValue",
    ()=>getSelectedOneofValue,
    "isOneofGroup",
    ()=>isOneofGroup,
    "setOneofValue",
    ()=>setOneofValue,
    "setUnknownOneofValue",
    ()=>setUnknownOneofValue
]);
function isOneofGroup(any) {
    if (typeof any != 'object' || any === null || !any.hasOwnProperty('oneofKind')) {
        return false;
    }
    switch(typeof any.oneofKind){
        case "string":
            if (any[any.oneofKind] === undefined) return false;
            return Object.keys(any).length == 2;
        case "undefined":
            return Object.keys(any).length == 1;
        default:
            return false;
    }
}
function getOneofValue(oneof, kind) {
    return oneof[kind];
}
function setOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined) {
        oneof[kind] = value;
    }
}
function setUnknownOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined && kind !== undefined) {
        oneof[kind] = value;
    }
}
function clearOneofValue(oneof) {
    if (oneof.oneofKind !== undefined) {
        delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = undefined;
}
function getSelectedOneofValue(oneof) {
    if (oneof.oneofKind === undefined) {
        return undefined;
    }
    return oneof[oneof.oneofKind];
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ReflectionTypeCheck",
    ()=>ReflectionTypeCheck
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$oneof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/oneof.js [app-client] (ecmascript)");
;
;
class ReflectionTypeCheck {
    constructor(info){
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    prepare() {
        if (this.data) return;
        const req = [], known = [], oneofs = [];
        for (let field of this.fields){
            if (field.oneof) {
                if (!oneofs.includes(field.oneof)) {
                    oneofs.push(field.oneof);
                    req.push(field.oneof);
                    known.push(field.oneof);
                }
            } else {
                known.push(field.localName);
                switch(field.kind){
                    case "scalar":
                    case "enum":
                        if (!field.opt || field.repeat) req.push(field.localName);
                        break;
                    case "message":
                        if (field.repeat) req.push(field.localName);
                        break;
                    case "map":
                        req.push(field.localName);
                        break;
                }
            }
        }
        this.data = {
            req,
            known,
            oneofs: Object.values(oneofs)
        };
    }
    /**
     * Is the argument a valid message as specified by the
     * reflection information?
     *
     * Checks all field types recursively. The `depth`
     * specifies how deep into the structure the check will be.
     *
     * With a depth of 0, only the presence of fields
     * is checked.
     *
     * With a depth of 1 or more, the field types are checked.
     *
     * With a depth of 2 or more, the members of map, repeated
     * and message fields are checked.
     *
     * Message fields will be checked recursively with depth - 1.
     *
     * The number of map entries / repeated values being checked
     * is < depth.
     */ is(message, depth, allowExcessProperties = false) {
        if (depth < 0) return true;
        if (message === null || message === undefined || typeof message != 'object') return false;
        this.prepare();
        let keys = Object.keys(message), data = this.data;
        // if a required field is missing in arg, this cannot be a T
        if (keys.length < data.req.length || data.req.some((n)=>!keys.includes(n))) return false;
        if (!allowExcessProperties) {
            // if the arg contains a key we dont know, this is not a literal T
            if (keys.some((k)=>!data.known.includes(k))) return false;
        }
        // "With a depth of 0, only the presence and absence of fields is checked."
        // "With a depth of 1 or more, the field types are checked."
        if (depth < 1) {
            return true;
        }
        // check oneof group
        for (const name of data.oneofs){
            const group = message[name];
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$oneof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOneofGroup"])(group)) return false;
            if (group.oneofKind === undefined) continue;
            const field = this.fields.find((f)=>f.localName === group.oneofKind);
            if (!field) return false; // we found no field, but have a kind, something is wrong
            if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth)) return false;
        }
        // check types
        for (const field of this.fields){
            if (field.oneof !== undefined) continue;
            if (!this.field(message[field.localName], field, allowExcessProperties, depth)) return false;
        }
        return true;
    }
    field(arg, field, allowExcessProperties, depth) {
        let repeated = field.repeat;
        switch(field.kind){
            case "scalar":
                if (arg === undefined) return field.opt;
                if (repeated) return this.scalars(arg, field.T, depth, field.L);
                return this.scalar(arg, field.T, field.L);
            case "enum":
                if (arg === undefined) return field.opt;
                if (repeated) return this.scalars(arg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32, depth);
                return this.scalar(arg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32);
            case "message":
                if (arg === undefined) return true;
                if (repeated) return this.messages(arg, field.T(), allowExcessProperties, depth);
                return this.message(arg, field.T(), allowExcessProperties, depth);
            case "map":
                if (typeof arg != 'object' || arg === null) return false;
                if (depth < 2) return true;
                if (!this.mapKeys(arg, field.K, depth)) return false;
                switch(field.V.kind){
                    case "scalar":
                        return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
                    case "enum":
                        return this.scalars(Object.values(arg), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32, depth);
                    case "message":
                        return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
                }
                break;
        }
        return true;
    }
    message(arg, type, allowExcessProperties, depth) {
        if (allowExcessProperties) {
            return type.isAssignable(arg, depth);
        }
        return type.is(arg, depth);
    }
    messages(arg, type, allowExcessProperties, depth) {
        if (!Array.isArray(arg)) return false;
        if (depth < 2) return true;
        if (allowExcessProperties) {
            for(let i = 0; i < arg.length && i < depth; i++)if (!type.isAssignable(arg[i], depth - 1)) return false;
        } else {
            for(let i = 0; i < arg.length && i < depth; i++)if (!type.is(arg[i], depth - 1)) return false;
        }
        return true;
    }
    scalar(arg, type, longType) {
        let argType = typeof arg;
        switch(type){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT64:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED64:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT64:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED64:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT64:
                switch(longType){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LongType"].BIGINT:
                        return argType == "bigint";
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LongType"].NUMBER:
                        return argType == "number" && !isNaN(arg);
                    default:
                        return argType == "string";
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BOOL:
                return argType == 'boolean';
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].STRING:
                return argType == 'string';
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BYTES:
                return arg instanceof Uint8Array;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].DOUBLE:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FLOAT:
                return argType == 'number' && !isNaN(arg);
            default:
                // case ScalarType.UINT32:
                // case ScalarType.FIXED32:
                // case ScalarType.INT32:
                // case ScalarType.SINT32:
                // case ScalarType.SFIXED32:
                return argType == 'number' && Number.isInteger(arg);
        }
    }
    scalars(arg, type, depth, longType) {
        if (!Array.isArray(arg)) return false;
        if (depth < 2) return true;
        if (Array.isArray(arg)) {
            for(let i = 0; i < arg.length && i < depth; i++)if (!this.scalar(arg[i], type, longType)) return false;
        }
        return true;
    }
    mapKeys(map, type, depth) {
        let keys = Object.keys(map);
        switch(type){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED32:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED32:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT32:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT32:
                return this.scalars(keys.slice(0, depth).map((k)=>parseInt(k)), type, depth);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BOOL:
                return this.scalars(keys.slice(0, depth).map((k)=>k == 'true' ? true : k == 'false' ? false : k), type, depth);
            default:
                return this.scalars(keys, type, depth, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LongType"].STRING);
        }
    }
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Get the type of a JSON value.
 * Distinguishes between array, null and object.
 */ __turbopack_context__.s([
    "isJsonObject",
    ()=>isJsonObject,
    "typeofJsonValue",
    ()=>typeofJsonValue
]);
function typeofJsonValue(value) {
    let t = typeof value;
    if (t == "object") {
        if (Array.isArray(value)) return "array";
        if (value === null) return "null";
    }
    return t;
}
function isJsonObject(value) {
    return value !== null && typeof value == "object" && !Array.isArray(value);
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/base64.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// lookup table from base64 character to byte
__turbopack_context__.s([
    "base64decode",
    ()=>base64decode,
    "base64encode",
    ()=>base64encode
]);
let encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
// lookup table from base64 character *code* to byte because lookup by number is fast
let decTable = [];
for(let i = 0; i < encTable.length; i++)decTable[encTable[i].charCodeAt(0)] = i;
// support base64url variants
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
function base64decode(base64Str) {
    // estimate byte size, not accounting for inner padding and whitespace
    let es = base64Str.length * 3 / 4;
    // if (es % 3 !== 0)
    // throw new Error('invalid base64 string');
    if (base64Str[base64Str.length - 2] == '=') es -= 2;
    else if (base64Str[base64Str.length - 1] == '=') es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0 // previous byte
    ;
    for(let i = 0; i < base64Str.length; i++){
        b = decTable[base64Str.charCodeAt(i)];
        if (b === undefined) {
            // noinspection FallThroughInSwitchStatementJS
            switch(base64Str[i]){
                case '=':
                    groupPos = 0; // reset state when padding found
                case '\n':
                case '\r':
                case '\t':
                case ' ':
                    continue; // skip white-space, and padding
                default:
                    throw Error(`invalid base64 string.`);
            }
        }
        switch(groupPos){
            case 0:
                p = b;
                groupPos = 1;
                break;
            case 1:
                bytes[bytePos++] = p << 2 | (b & 48) >> 4;
                p = b;
                groupPos = 2;
                break;
            case 2:
                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
                p = b;
                groupPos = 3;
                break;
            case 3:
                bytes[bytePos++] = (p & 3) << 6 | b;
                groupPos = 0;
                break;
        }
    }
    if (groupPos == 1) throw Error(`invalid base64 string.`);
    return bytes.subarray(0, bytePos);
}
function base64encode(bytes) {
    let base64 = '', groupPos = 0, b, p = 0; // carry over from previous byte
    for(let i = 0; i < bytes.length; i++){
        b = bytes[i];
        switch(groupPos){
            case 0:
                base64 += encTable[b >> 2];
                p = (b & 3) << 4;
                groupPos = 1;
                break;
            case 1:
                base64 += encTable[p | b >> 4];
                p = (b & 15) << 2;
                groupPos = 2;
                break;
            case 2:
                base64 += encTable[p | b >> 6];
                base64 += encTable[b & 63];
                groupPos = 0;
                break;
        }
    }
    // padding required?
    if (groupPos) {
        base64 += encTable[p];
        base64 += '=';
        if (groupPos == 1) base64 += '=';
    }
    return base64;
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright 2008 Google Inc.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Code generated by the Protocol Buffer compiler is owned by the owner
// of the input file used when generating it.  This code is not
// standalone and requires a support library to be linked with it.  This
// support library is itself covered by the above license.
/**
 * Read a 64 bit varint as two JS numbers.
 *
 * Returns tuple:
 * [0]: low bits
 * [0]: high bits
 *
 * Copyright 2008 Google Inc.  All rights reserved.
 *
 * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
 */ __turbopack_context__.s([
    "int64fromString",
    ()=>int64fromString,
    "int64toString",
    ()=>int64toString,
    "varint32read",
    ()=>varint32read,
    "varint32write",
    ()=>varint32write,
    "varint64read",
    ()=>varint64read,
    "varint64write",
    ()=>varint64write
]);
function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for(let shift = 0; shift < 28; shift += 7){
        let b = this.buf[this.pos++];
        lowBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [
                lowBits,
                highBits
            ];
        }
    }
    let middleByte = this.buf[this.pos++];
    // last four bits of the first 32 bit number
    lowBits |= (middleByte & 0x0F) << 28;
    // 3 upper bits are part of the next 32 bit number
    highBits = (middleByte & 0x70) >> 4;
    if ((middleByte & 0x80) == 0) {
        this.assertBounds();
        return [
            lowBits,
            highBits
        ];
    }
    for(let shift = 3; shift <= 31; shift += 7){
        let b = this.buf[this.pos++];
        highBits |= (b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            this.assertBounds();
            return [
                lowBits,
                highBits
            ];
        }
    }
    throw new Error('invalid varint');
}
function varint64write(lo, hi, bytes) {
    for(let i = 0; i < 28; i = i + 7){
        const shift = lo >>> i;
        const hasNext = !(shift >>> 7 == 0 && hi == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    const splitBits = lo >>> 28 & 0x0F | (hi & 0x07) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xFF);
    if (!hasMoreBits) {
        return;
    }
    for(let i = 3; i < 31; i = i + 7){
        const shift = hi >>> i;
        const hasNext = !(shift >>> 7 == 0);
        const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
        bytes.push(byte);
        if (!hasNext) {
            return;
        }
    }
    bytes.push(hi >>> 31 & 0x01);
}
// constants for binary math
const TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
function int64fromString(dec) {
    // Check for minus sign.
    let minus = dec[0] == '-';
    if (minus) dec = dec.slice(1);
    // Work 6 decimal digits at a time, acting like we're converting base 1e6
    // digits to binary. This is safe to do with floating point math because
    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
        // Note: Number('') is 0.
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        // Carry bits from lowBits to highBits
        if (lowBits >= TWO_PWR_32_DBL) {
            highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
            lowBits = lowBits % TWO_PWR_32_DBL;
        }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return [
        minus,
        lowBits,
        highBits
    ];
}
function int64toString(bitsLow, bitsHigh) {
    // Skip the expensive conversion if the number is small enough to use the
    // built-in conversions.
    if (bitsHigh >>> 0 <= 0x1FFFFF) {
        return '' + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
    }
    // What this code is doing is essentially converting the input number from
    // base-2 to base-1e7, which allows us to represent the 64-bit range with
    // only 3 (very large) digits. Those digits are then trivial to convert to
    // a base-10 string.
    // The magic numbers used here are -
    // 2^24 = 16777216 = (1,6777216) in base-1e7.
    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
    // Split 32:32 representation into 16:24:24 representation so our
    // intermediate digits don't overflow.
    let low = bitsLow & 0xFFFFFF;
    let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 0xFFFFFF;
    let high = bitsHigh >> 16 & 0xFFFF;
    // Assemble our three base-1e7 digits, ignoring carries. The maximum
    // value in a digit at this step is representable as a 48-bit integer, which
    // can be stored in a 64-bit floating point number.
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    // Apply carries from A to B and from B to C.
    let base = 10000000;
    if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
    }
    if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
    }
    // Convert base-1e7 digits to base-10, with optional leading zeroes.
    function decimalFrom1e7(digit1e7, needLeadingZeros) {
        let partial = digit1e7 ? String(digit1e7) : '';
        if (needLeadingZeros) {
            return '0000000'.slice(partial.length) + partial;
        }
        return partial;
    }
    return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) + decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) + // If the final 1e7 digit didn't need leading zeros, we would have
    // returned via the trivial code path at the top.
    decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);
}
function varint32write(value, bytes) {
    if (value >= 0) {
        // write value as varint 32
        while(value > 0x7f){
            bytes.push(value & 0x7f | 0x80);
            value = value >>> 7;
        }
        bytes.push(value);
    } else {
        for(let i = 0; i < 9; i++){
            bytes.push(value & 127 | 128);
            value = value >> 7;
        }
        bytes.push(1);
    }
}
function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 0x7F;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 7;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 14;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 0x7F) << 21;
    if ((b & 0x80) == 0) {
        this.assertBounds();
        return result;
    }
    // Extract only last 4 bits
    b = this.buf[this.pos++];
    result |= (b & 0x0F) << 28;
    for(let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)b = this.buf[this.pos++];
    if ((b & 0x80) != 0) throw new Error('invalid varint');
    this.assertBounds();
    // Result can have 32 bits, convert it to unsigned
    return result >>> 0;
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PbLong",
    ()=>PbLong,
    "PbULong",
    ()=>PbULong,
    "detectBi",
    ()=>detectBi
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js [app-client] (ecmascript)");
;
let BI;
function detectBi() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = globalThis.BigInt !== undefined && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
    BI = ok ? {
        MIN: BigInt("-9223372036854775808"),
        MAX: BigInt("9223372036854775807"),
        UMIN: BigInt("0"),
        UMAX: BigInt("18446744073709551615"),
        C: BigInt,
        V: dv
    } : undefined;
}
detectBi();
function assertBi(bi) {
    if (!bi) throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
// used to validate from(string) input (when bigint is unavailable)
const RE_DECIMAL_STR = /^-?[0-9]+$/;
// constants for binary math
const TWO_PWR_32_DBL = 0x100000000;
const HALF_2_PWR_32 = 0x080000000;
// base class for PbLong and PbULong provides shared code
class SharedPbLong {
    /**
     * Create a new instance with the given bits.
     */ constructor(lo, hi){
        this.lo = lo | 0;
        this.hi = hi | 0;
    }
    /**
     * Is this instance equal to 0?
     */ isZero() {
        return this.lo == 0 && this.hi == 0;
    }
    /**
     * Convert to a native number.
     */ toNumber() {
        let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
        if (!Number.isSafeInteger(result)) throw new Error("cannot convert to safe number");
        return result;
    }
}
class PbULong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */ static from(value) {
        if (BI) // noinspection FallThroughInSwitchStatementJS
        switch(typeof value){
            case "string":
                if (value == "0") return this.ZERO;
                if (value == "") throw new Error('string is no integer');
                value = BI.C(value);
            case "number":
                if (value === 0) return this.ZERO;
                value = BI.C(value);
            case "bigint":
                if (!value) return this.ZERO;
                if (value < BI.UMIN) throw new Error('signed value for ulong');
                if (value > BI.UMAX) throw new Error('ulong too large');
                BI.V.setBigUint64(0, value, true);
                return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
        }
        else switch(typeof value){
            case "string":
                if (value == "0") return this.ZERO;
                value = value.trim();
                if (!RE_DECIMAL_STR.test(value)) throw new Error('string is no integer');
                let [minus, lo, hi] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["int64fromString"])(value);
                if (minus) throw new Error('signed value for ulong');
                return new PbULong(lo, hi);
            case "number":
                if (value == 0) return this.ZERO;
                if (!Number.isSafeInteger(value)) throw new Error('number is no integer');
                if (value < 0) throw new Error('signed value for ulong');
                return new PbULong(value, value / TWO_PWR_32_DBL);
        }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Convert to decimal string.
     */ toString() {
        return BI ? this.toBigInt().toString() : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["int64toString"])(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */ toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigUint64(0, true);
    }
}
/**
 * ulong 0 singleton.
 */ PbULong.ZERO = new PbULong(0, 0);
class PbLong extends SharedPbLong {
    /**
     * Create instance from a `string`, `number` or `bigint`.
     */ static from(value) {
        if (BI) // noinspection FallThroughInSwitchStatementJS
        switch(typeof value){
            case "string":
                if (value == "0") return this.ZERO;
                if (value == "") throw new Error('string is no integer');
                value = BI.C(value);
            case "number":
                if (value === 0) return this.ZERO;
                value = BI.C(value);
            case "bigint":
                if (!value) return this.ZERO;
                if (value < BI.MIN) throw new Error('signed long too small');
                if (value > BI.MAX) throw new Error('signed long too large');
                BI.V.setBigInt64(0, value, true);
                return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
        }
        else switch(typeof value){
            case "string":
                if (value == "0") return this.ZERO;
                value = value.trim();
                if (!RE_DECIMAL_STR.test(value)) throw new Error('string is no integer');
                let [minus, lo, hi] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["int64fromString"])(value);
                if (minus) {
                    if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0) throw new Error('signed long too small');
                } else if (hi >= HALF_2_PWR_32) throw new Error('signed long too large');
                let pbl = new PbLong(lo, hi);
                return minus ? pbl.negate() : pbl;
            case "number":
                if (value == 0) return this.ZERO;
                if (!Number.isSafeInteger(value)) throw new Error('number is no integer');
                return value > 0 ? new PbLong(value, value / TWO_PWR_32_DBL) : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
        }
        throw new Error('unknown value ' + typeof value);
    }
    /**
     * Do we have a minus sign?
     */ isNegative() {
        return (this.hi & HALF_2_PWR_32) !== 0;
    }
    /**
     * Negate two's complement.
     * Invert all the bits and add one to the result.
     */ negate() {
        let hi = ~this.hi, lo = this.lo;
        if (lo) lo = ~lo + 1;
        else hi += 1;
        return new PbLong(lo, hi);
    }
    /**
     * Convert to decimal string.
     */ toString() {
        if (BI) return this.toBigInt().toString();
        if (this.isNegative()) {
            let n = this.negate();
            return '-' + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["int64toString"])(n.lo, n.hi);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["int64toString"])(this.lo, this.hi);
    }
    /**
     * Convert to native bigint.
     */ toBigInt() {
        assertBi(BI);
        BI.V.setInt32(0, this.lo, true);
        BI.V.setInt32(4, this.hi, true);
        return BI.V.getBigInt64(0, true);
    }
}
/**
 * long 0 singleton.
 */ PbLong.ZERO = new PbLong(0, 0);
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/assert.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * assert that condition is true or throw error (with message)
 */ __turbopack_context__.s([
    "assert",
    ()=>assert,
    "assertFloat32",
    ()=>assertFloat32,
    "assertInt32",
    ()=>assertInt32,
    "assertNever",
    ()=>assertNever,
    "assertUInt32",
    ()=>assertUInt32
]);
function assert(condition, msg) {
    if (!condition) {
        throw new Error(msg);
    }
}
function assertNever(value, msg) {
    throw new Error(msg !== null && msg !== void 0 ? msg : 'Unexpected object: ' + value);
}
const FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -3.4028234663852886e+38, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -0X80000000;
function assertInt32(arg) {
    if (typeof arg !== "number") throw new Error('invalid int 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error('invalid int 32: ' + arg);
}
function assertUInt32(arg) {
    if (typeof arg !== "number") throw new Error('invalid uint 32: ' + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error('invalid uint 32: ' + arg);
}
function assertFloat32(arg) {
    if (typeof arg !== "number") throw new Error('invalid float 32: ' + typeof arg);
    if (!Number.isFinite(arg)) return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error('invalid float 32: ' + arg);
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "reflectionLongConvert",
    ()=>reflectionLongConvert
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js [app-client] (ecmascript)");
;
function reflectionLongConvert(long, type) {
    switch(type){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LongType"].BIGINT:
            return long.toBigInt();
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LongType"].NUMBER:
            return long.toNumber();
        default:
            // case undefined:
            // case LongType.STRING:
            return long.toString();
    }
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ReflectionJsonReader",
    ()=>ReflectionJsonReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$json$2d$typings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/assert.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js [app-client] (ecmascript)");
;
;
;
;
;
;
class ReflectionJsonReader {
    constructor(info){
        this.info = info;
    }
    prepare() {
        var _a;
        if (this.fMap === undefined) {
            this.fMap = {};
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            for (const field of fieldsInput){
                this.fMap[field.name] = field;
                this.fMap[field.jsonName] = field;
                this.fMap[field.localName] = field;
            }
        }
    }
    // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
    assert(condition, fieldName, jsonValue) {
        if (!condition) {
            let what = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$json$2d$typings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeofJsonValue"])(jsonValue);
            if (what == "number" || what == "boolean") what = jsonValue.toString();
            throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
        }
    }
    /**
     * Reads a message from canonical JSON format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */ read(input, message, options) {
        this.prepare();
        const oneofsHandled = [];
        for (const [jsonKey, jsonValue] of Object.entries(input)){
            const field = this.fMap[jsonKey];
            if (!field) {
                if (!options.ignoreUnknownFields) throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
                continue;
            }
            const localName = field.localName;
            // handle oneof ADT
            let target; // this will be the target for the field value, whether it is member of a oneof or not
            if (field.oneof) {
                if (jsonValue === null && (field.kind !== 'enum' || field.T()[0] !== 'google.protobuf.NullValue')) {
                    continue;
                }
                // since json objects are unordered by specification, it is not possible to take the last of multiple oneofs
                if (oneofsHandled.includes(field.oneof)) throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
                oneofsHandled.push(field.oneof);
                target = message[field.oneof] = {
                    oneofKind: localName
                };
            } else {
                target = message;
            }
            // we have handled oneof above. we just have read the value into `target`.
            if (field.kind == 'map') {
                if (jsonValue === null) {
                    continue;
                }
                // check input
                this.assert((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$json$2d$typings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isJsonObject"])(jsonValue), field.name, jsonValue);
                // our target to put map entries into
                const fieldObj = target[localName];
                // read entries
                for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)){
                    this.assert(jsonObjValue !== null, field.name + " map value", null);
                    // read value
                    let val;
                    switch(field.V.kind){
                        case "message":
                            val = field.V.T().internalJsonRead(jsonObjValue, options);
                            break;
                        case "enum":
                            val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                            if (val === false) continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name + " map value", jsonObjValue);
                    // read key
                    let key = jsonObjKey;
                    if (field.K == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BOOL) key = key == "true" ? true : key == "false" ? false : key;
                    key = this.scalar(key, field.K, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LongType"].STRING, field.name).toString();
                    fieldObj[key] = val;
                }
            } else if (field.repeat) {
                if (jsonValue === null) continue;
                // check input
                this.assert(Array.isArray(jsonValue), field.name, jsonValue);
                // our target to put array entries into
                const fieldArr = target[localName];
                // read array entries
                for (const jsonItem of jsonValue){
                    this.assert(jsonItem !== null, field.name, null);
                    let val;
                    switch(field.kind){
                        case "message":
                            val = field.T().internalJsonRead(jsonItem, options);
                            break;
                        case "enum":
                            val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                            if (val === false) continue;
                            break;
                        case "scalar":
                            val = this.scalar(jsonItem, field.T, field.L, field.name);
                            break;
                    }
                    this.assert(val !== undefined, field.name, jsonValue);
                    fieldArr.push(val);
                }
            } else {
                switch(field.kind){
                    case "message":
                        if (jsonValue === null && field.T().typeName != 'google.protobuf.Value') {
                            this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                            continue;
                        }
                        target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
                        break;
                    case "enum":
                        if (jsonValue === null) continue;
                        let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
                        if (val === false) continue;
                        target[localName] = val;
                        break;
                    case "scalar":
                        if (jsonValue === null) continue;
                        target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
                        break;
                }
            }
        }
    }
    /**
     * Returns `false` for unrecognized string representations.
     *
     * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
     */ enum(type, json, fieldName, ignoreUnknownFields) {
        if (type[0] == 'google.protobuf.NullValue') (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
        if (json === null) // we require 0 to be default value for all enums
        return 0;
        switch(typeof json){
            case "number":
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
                return json;
            case "string":
                let localEnumName = json;
                if (type[2] && json.substring(0, type[2].length) === type[2]) // lookup without the shared prefix
                localEnumName = json.substring(type[2].length);
                let enumNumber = type[1][localEnumName];
                if (typeof enumNumber === 'undefined' && ignoreUnknownFields) {
                    return false;
                }
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
                return enumNumber;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
    }
    scalar(json, type, longType, fieldName) {
        let e;
        try {
            switch(type){
                // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
                // Either numbers or strings are accepted. Exponent notation is also accepted.
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].DOUBLE:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FLOAT:
                    if (json === null) return .0;
                    if (json === "NaN") return Number.NaN;
                    if (json === "Infinity") return Number.POSITIVE_INFINITY;
                    if (json === "-Infinity") return Number.NEGATIVE_INFINITY;
                    if (json === "") {
                        e = "empty string";
                        break;
                    }
                    if (typeof json == "string" && json.trim().length !== json.length) {
                        e = "extra whitespace";
                        break;
                    }
                    if (typeof json != "string" && typeof json != "number") {
                        break;
                    }
                    let float = Number(json);
                    if (Number.isNaN(float)) {
                        e = "not a number";
                        break;
                    }
                    if (!Number.isFinite(float)) {
                        // infinity and -infinity are handled by string representation above, so this is an error
                        e = "too large or small";
                        break;
                    }
                    if (type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FLOAT) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertFloat32"])(float);
                    return float;
                // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED32:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED32:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT32:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT32:
                    if (json === null) return 0;
                    let int32;
                    if (typeof json == "number") int32 = json;
                    else if (json === "") e = "empty string";
                    else if (typeof json == "string") {
                        if (json.trim().length !== json.length) e = "extra whitespace";
                        else int32 = Number(json);
                    }
                    if (int32 === undefined) break;
                    if (type == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT32) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertUInt32"])(int32);
                    else (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertInt32"])(int32);
                    return int32;
                // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT64:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED64:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT64:
                    if (json === null) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionLongConvert"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"].ZERO, longType);
                    if (typeof json != "number" && typeof json != "string") break;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionLongConvert"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"].from(json), longType);
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED64:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT64:
                    if (json === null) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionLongConvert"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbULong"].ZERO, longType);
                    if (typeof json != "number" && typeof json != "string") break;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionLongConvert"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbULong"].from(json), longType);
                // bool:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BOOL:
                    if (json === null) return false;
                    if (typeof json !== "boolean") break;
                    return json;
                // string:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].STRING:
                    if (json === null) return "";
                    if (typeof json !== "string") {
                        e = "extra whitespace";
                        break;
                    }
                    try {
                        encodeURIComponent(json);
                    } catch (e) {
                        e = "invalid UTF8";
                        break;
                    }
                    return json;
                // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
                // Either standard or URL-safe base64 encoding with/without paddings are accepted.
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BYTES:
                    if (json === null || json === "") return new Uint8Array(0);
                    if (typeof json !== 'string') break;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64decode"])(json);
            }
        } catch (error) {
            e = error.message;
        }
        this.assert(false, fieldName + (e ? " - " + e : ""), json);
    }
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ReflectionJsonWriter",
    ()=>ReflectionJsonWriter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/assert.js [app-client] (ecmascript)");
;
;
;
;
class ReflectionJsonWriter {
    constructor(info){
        var _a;
        this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Converts the message to a JSON object, based on the field descriptors.
     */ write(message, options) {
        const json = {}, source = message;
        for (const field of this.fields){
            // field is not part of a oneof, simply write as is
            if (!field.oneof) {
                let jsonValue = this.field(field, source[field.localName], options);
                if (jsonValue !== undefined) json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
                continue;
            }
            // field is part of a oneof
            const group = source[field.oneof];
            if (group.oneofKind !== field.localName) continue; // not selected, skip
            const opt = field.kind == 'scalar' || field.kind == 'enum' ? Object.assign(Object.assign({}, options), {
                emitDefaultValues: true
            }) : options;
            let jsonValue = this.field(field, group[field.localName], opt);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(jsonValue !== undefined);
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
        }
        return json;
    }
    field(field, value, options) {
        let jsonValue = undefined;
        if (field.kind == 'map') {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(typeof value == "object" && value !== null);
            const jsonObj = {};
            switch(field.V.kind){
                case "scalar":
                    for (const [entryKey, entryValue] of Object.entries(value)){
                        const val = this.scalar(field.V.T, entryValue, field.name, false, true);
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "message":
                    const messageType = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)){
                        const val = this.message(messageType, entryValue, field.name, options);
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
                case "enum":
                    const enumInfo = field.V.T();
                    for (const [entryKey, entryValue] of Object.entries(value)){
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(entryValue === undefined || typeof entryValue == 'number');
                        const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(val !== undefined);
                        jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                    }
                    break;
            }
            if (options.emitDefaultValues || Object.keys(jsonObj).length > 0) jsonValue = jsonObj;
        } else if (field.repeat) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(Array.isArray(value));
            const jsonArr = [];
            switch(field.kind){
                case "scalar":
                    for(let i = 0; i < value.length; i++){
                        const val = this.scalar(field.T, value[i], field.name, field.opt, true);
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "enum":
                    const enumInfo = field.T();
                    for(let i = 0; i < value.length; i++){
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(value[i] === undefined || typeof value[i] == 'number');
                        const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
                case "message":
                    const messageType = field.T();
                    for(let i = 0; i < value.length; i++){
                        const val = this.message(messageType, value[i], field.name, options);
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(val !== undefined);
                        jsonArr.push(val);
                    }
                    break;
            }
            // add converted array to json output
            if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues) jsonValue = jsonArr;
        } else {
            switch(field.kind){
                case "scalar":
                    jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
                    break;
                case "enum":
                    jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
                    break;
                case "message":
                    jsonValue = this.message(field.T(), value, field.name, options);
                    break;
            }
        }
        return jsonValue;
    }
    /**
     * Returns `null` as the default for google.protobuf.NullValue.
     */ enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
        if (type[0] == 'google.protobuf.NullValue') return !emitDefaultValues && !optional ? undefined : null;
        if (value === undefined) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(optional);
            return undefined;
        }
        if (value === 0 && !emitDefaultValues && !optional) // we require 0 to be default value for all enums
        return undefined;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(typeof value == 'number');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(Number.isInteger(value));
        if (enumAsInteger || !type[1].hasOwnProperty(value)) // if we don't now the enum value, just return the number
        return value;
        if (type[2]) // restore the dropped prefix
        return type[2] + type[1][value];
        return type[1][value];
    }
    message(type, value, fieldName, options) {
        if (value === undefined) return options.emitDefaultValues ? null : undefined;
        return type.internalJsonWrite(value, options);
    }
    scalar(type, value, fieldName, optional, emitDefaultValues) {
        if (value === undefined) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(optional);
            return undefined;
        }
        const ed = emitDefaultValues || optional;
        // noinspection FallThroughInSwitchStatementJS
        switch(type){
            // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED32:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT32:
                if (value === 0) return ed ? 0 : undefined;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertInt32"])(value);
                return value;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED32:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT32:
                if (value === 0) return ed ? 0 : undefined;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertUInt32"])(value);
                return value;
            // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
            // Either numbers or strings are accepted. Exponent notation is also accepted.
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FLOAT:
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertFloat32"])(value);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].DOUBLE:
                if (value === 0) return ed ? 0 : undefined;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(typeof value == 'number');
                if (Number.isNaN(value)) return 'NaN';
                if (value === Number.POSITIVE_INFINITY) return 'Infinity';
                if (value === Number.NEGATIVE_INFINITY) return '-Infinity';
                return value;
            // string:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].STRING:
                if (value === "") return ed ? '' : undefined;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(typeof value == 'string');
                return value;
            // bool:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BOOL:
                if (value === false) return ed ? false : undefined;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(typeof value == 'boolean');
                return value;
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT64:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED64:
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let ulong = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbULong"].from(value);
                if (ulong.isZero() && !ed) return undefined;
                return ulong.toString();
            // JSON value will be a decimal string. Either numbers or strings are accepted.
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT64:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED64:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT64:
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                let long = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"].from(value);
                if (long.isZero() && !ed) return undefined;
                return long.toString();
            // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
            // Either standard or URL-safe base64 encoding with/without paddings are accepted.
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BYTES:
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(value instanceof Uint8Array);
                if (!value.byteLength) return ed ? "" : undefined;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64encode"])(value);
        }
    }
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * This handler implements the default behaviour for unknown fields.
 * When reading data, unknown fields are stored on the message, in a
 * symbol property.
 * When writing data, the symbol property is queried and unknown fields
 * are serialized into the output again.
 */ __turbopack_context__.s([
    "UnknownFieldHandler",
    ()=>UnknownFieldHandler,
    "WireType",
    ()=>WireType,
    "mergeBinaryOptions",
    ()=>mergeBinaryOptions
]);
var UnknownFieldHandler;
(function(UnknownFieldHandler) {
    /**
     * The symbol used to store unknown fields for a message.
     * The property must conform to `UnknownFieldContainer`.
     */ UnknownFieldHandler.symbol = Symbol.for("protobuf-ts/unknown");
    /**
     * Store an unknown field during binary read directly on the message.
     * This method is compatible with `BinaryReadOptions.readUnknownField`.
     */ UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data)=>{
        let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];
        container.push({
            no: fieldNo,
            wireType,
            data
        });
    };
    /**
     * Write unknown fields stored for the message to the writer.
     * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.
     */ UnknownFieldHandler.onWrite = (typeName, message, writer)=>{
        for (let { no, wireType, data } of UnknownFieldHandler.list(message))writer.tag(no, wireType).raw(data);
    };
    /**
     * List unknown fields stored for the message.
     * Note that there may be multiples fields with the same number.
     */ UnknownFieldHandler.list = (message, fieldNo)=>{
        if (is(message)) {
            let all = message[UnknownFieldHandler.symbol];
            return fieldNo ? all.filter((uf)=>uf.no == fieldNo) : all;
        }
        return [];
    };
    /**
     * Returns the last unknown field by field number.
     */ UnknownFieldHandler.last = (message, fieldNo)=>UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];
    const is = (message)=>message && Array.isArray(message[UnknownFieldHandler.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
function mergeBinaryOptions(a, b) {
    return Object.assign(Object.assign({}, a), b);
}
var WireType;
(function(WireType) {
    /**
     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
     */ WireType[WireType["Varint"] = 0] = "Varint";
    /**
     * Used for fixed64, sfixed64, double.
     * Always 8 bytes with little-endian byte order.
     */ WireType[WireType["Bit64"] = 1] = "Bit64";
    /**
     * Used for string, bytes, embedded messages, packed repeated fields
     *
     * Only repeated numeric types (types which use the varint, 32-bit,
     * or 64-bit wire types) can be packed. In proto3, such fields are
     * packed by default.
     */ WireType[WireType["LengthDelimited"] = 2] = "LengthDelimited";
    /**
     * Used for groups
     * @deprecated
     */ WireType[WireType["StartGroup"] = 3] = "StartGroup";
    /**
     * Used for groups
     * @deprecated
     */ WireType[WireType["EndGroup"] = 4] = "EndGroup";
    /**
     * Used for fixed32, sfixed32, float.
     * Always 4 bytes with little-endian byte order.
     */ WireType[WireType["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "reflectionScalarDefault",
    ()=>reflectionScalarDefault
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js [app-client] (ecmascript)");
;
;
;
function reflectionScalarDefault(type, longType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LongType"].STRING) {
    switch(type){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BOOL:
            return false;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT64:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED64:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionLongConvert"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbULong"].ZERO, longType);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT64:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED64:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT64:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionLongConvert"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"].ZERO, longType);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].DOUBLE:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FLOAT:
            return 0.0;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BYTES:
            return new Uint8Array(0);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].STRING:
            return "";
        default:
            // case ScalarType.INT32:
            // case ScalarType.UINT32:
            // case ScalarType.SINT32:
            // case ScalarType.FIXED32:
            // case ScalarType.SFIXED32:
            return 0;
    }
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ReflectionBinaryReader",
    ()=>ReflectionBinaryReader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$scalar$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js [app-client] (ecmascript)");
;
;
;
;
class ReflectionBinaryReader {
    constructor(info){
        this.info = info;
    }
    prepare() {
        var _a;
        if (!this.fieldNoToField) {
            const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
            this.fieldNoToField = new Map(fieldsInput.map((field)=>[
                    field.no,
                    field
                ]));
        }
    }
    /**
     * Reads a message from binary format into the target message.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */ read(reader, message, options, length) {
        this.prepare();
        const end = length === undefined ? reader.len : reader.pos + length;
        while(reader.pos < end){
            // read the tag and find the field
            const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
            if (!field) {
                let u = options.readUnknownField;
                if (u == "throw") throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
                let d = reader.skip(wireType);
                if (u !== false) (u === true ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnknownFieldHandler"].onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
                continue;
            }
            // target object for the field we are reading
            let target = message, repeated = field.repeat, localName = field.localName;
            // if field is member of oneof ADT, use ADT as target
            if (field.oneof) {
                target = target[field.oneof];
                // if other oneof member selected, set new ADT
                if (target.oneofKind !== localName) target = message[field.oneof] = {
                    oneofKind: localName
                };
            }
            // we have handled oneof above, we just have read the value into `target[localName]`
            switch(field.kind){
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32 : field.T;
                    let L = field.kind == "scalar" ? field.L : undefined;
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        if (wireType == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].LengthDelimited && T != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].STRING && T != __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BYTES) {
                            let e = reader.uint32() + reader.pos;
                            while(reader.pos < e)arr.push(this.scalar(reader, T, L));
                        } else arr.push(this.scalar(reader, T, L));
                    } else target[localName] = this.scalar(reader, T, L);
                    break;
                case "message":
                    if (repeated) {
                        let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                        let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
                        arr.push(msg);
                    } else target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
                    break;
                case "map":
                    let [mapKey, mapVal] = this.mapEntry(field, reader, options);
                    // safe to assume presence of map object, oneof cannot contain repeated values
                    target[localName][mapKey] = mapVal;
                    break;
            }
        }
    }
    /**
     * Read a map field, expecting key field = 1, value field = 2
     */ mapEntry(field, reader, options) {
        let length = reader.uint32();
        let end = reader.pos + length;
        let key = undefined; // javascript only allows number or string for object properties
        let val = undefined;
        while(reader.pos < end){
            let [fieldNo, wireType] = reader.tag();
            switch(fieldNo){
                case 1:
                    if (field.K == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BOOL) key = reader.bool().toString();
                    else // long types are read as string, number types are okay as number
                    key = this.scalar(reader, field.K, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LongType"].STRING);
                    break;
                case 2:
                    switch(field.V.kind){
                        case "scalar":
                            val = this.scalar(reader, field.V.T, field.V.L);
                            break;
                        case "enum":
                            val = reader.int32();
                            break;
                        case "message":
                            val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                            break;
                    }
                    break;
                default:
                    throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
            }
        }
        if (key === undefined) {
            let keyRaw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$scalar$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionScalarDefault"])(field.K);
            key = field.K == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BOOL ? keyRaw.toString() : keyRaw;
        }
        if (val === undefined) switch(field.V.kind){
            case "scalar":
                val = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$scalar$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionScalarDefault"])(field.V.T, field.V.L);
                break;
            case "enum":
                val = 0;
                break;
            case "message":
                val = field.V.T().create();
                break;
        }
        return [
            key,
            val
        ];
    }
    scalar(reader, type, longType) {
        switch(type){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32:
                return reader.int32();
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].STRING:
                return reader.string();
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BOOL:
                return reader.bool();
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].DOUBLE:
                return reader.double();
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FLOAT:
                return reader.float();
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT64:
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionLongConvert"])(reader.int64(), longType);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT64:
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionLongConvert"])(reader.uint64(), longType);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED64:
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionLongConvert"])(reader.fixed64(), longType);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED32:
                return reader.fixed32();
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BYTES:
                return reader.bytes();
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT32:
                return reader.uint32();
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED32:
                return reader.sfixed32();
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED64:
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionLongConvert"])(reader.sfixed64(), longType);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT32:
                return reader.sint32();
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT64:
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$long$2d$convert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionLongConvert"])(reader.sint64(), longType);
        }
    }
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ReflectionBinaryWriter",
    ()=>ReflectionBinaryWriter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/assert.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js [app-client] (ecmascript)");
;
;
;
;
class ReflectionBinaryWriter {
    constructor(info){
        this.info = info;
    }
    prepare() {
        if (!this.fields) {
            const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
            this.fields = fieldsInput.sort((a, b)=>a.no - b.no);
        }
    }
    /**
     * Writes the message to binary format.
     */ write(message, writer, options) {
        this.prepare();
        for (const field of this.fields){
            let value, emitDefault, repeated = field.repeat, localName = field.localName;
            // handle oneof ADT
            if (field.oneof) {
                const group = message[field.oneof];
                if (group.oneofKind !== localName) continue; // if field is not selected, skip
                value = group[localName];
                emitDefault = true;
            } else {
                value = message[localName];
                emitDefault = false;
            }
            // we have handled oneof above. we just have to honor `emitDefault`.
            switch(field.kind){
                case "scalar":
                case "enum":
                    let T = field.kind == "enum" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32 : field.T;
                    if (repeated) {
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(Array.isArray(value));
                        if (repeated == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatType"].PACKED) this.packed(writer, T, field.no, value);
                        else for (const item of value)this.scalar(writer, T, field.no, item, true);
                    } else if (value === undefined) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(field.opt);
                    else this.scalar(writer, T, field.no, value, emitDefault || field.opt);
                    break;
                case "message":
                    if (repeated) {
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(Array.isArray(value));
                        for (const item of value)this.message(writer, options, field.T(), field.no, item);
                    } else {
                        this.message(writer, options, field.T(), field.no, value);
                    }
                    break;
                case "map":
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(typeof value == 'object' && value !== null);
                    for (const [key, val] of Object.entries(value))this.mapEntry(writer, options, field, key, val);
                    break;
            }
        }
        let u = options.writeUnknownFields;
        if (u !== false) (u === true ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UnknownFieldHandler"].onWrite : u)(this.info.typeName, message, writer);
    }
    mapEntry(writer, options, field, key, value) {
        writer.tag(field.no, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].LengthDelimited);
        writer.fork();
        // javascript only allows number or string for object properties
        // we convert from our representation to the protobuf type
        let keyValue = key;
        switch(field.K){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED32:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT32:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED32:
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT32:
                keyValue = Number.parseInt(key);
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BOOL:
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(key == 'true' || key == 'false');
                keyValue = key == 'true';
                break;
        }
        // write key, expecting key field number = 1
        this.scalar(writer, field.K, 1, keyValue, true);
        // write value, expecting value field number = 2
        switch(field.V.kind){
            case 'scalar':
                this.scalar(writer, field.V.T, 2, value, true);
                break;
            case 'enum':
                this.scalar(writer, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32, 2, value, true);
                break;
            case 'message':
                this.message(writer, options, field.V.T(), 2, value);
                break;
        }
        writer.join();
    }
    message(writer, options, handler, fieldNo, value) {
        if (value === undefined) return;
        handler.internalBinaryWrite(value, writer.tag(fieldNo, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].LengthDelimited).fork(), options);
        writer.join();
    }
    /**
     * Write a single scalar value.
     */ scalar(writer, type, fieldNo, value, emitDefault) {
        let [wireType, method, isDefault] = this.scalarInfo(type, value);
        if (!isDefault || emitDefault) {
            writer.tag(fieldNo, wireType);
            writer[method](value);
        }
    }
    /**
     * Write an array of scalar values in packed format.
     */ packed(writer, type, fieldNo, value) {
        if (!value.length) return;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assert"])(type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BYTES && type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].STRING);
        // write tag
        writer.tag(fieldNo, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].LengthDelimited);
        // begin length-delimited
        writer.fork();
        // write values without tags
        let [, method] = this.scalarInfo(type);
        for(let i = 0; i < value.length; i++)writer[method](value[i]);
        // end length delimited
        writer.join();
    }
    /**
     * Get information for writing a scalar value.
     *
     * Returns tuple:
     * [0]: appropriate WireType
     * [1]: name of the appropriate method of IBinaryWriter
     * [2]: whether the given value is a default value
     *
     * If argument `value` is omitted, [2] is always false.
     */ scalarInfo(type, value) {
        let t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].Varint;
        let m;
        let i = value === undefined;
        let d = value === 0;
        switch(type){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32:
                m = "int32";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].STRING:
                d = i || !value.length;
                t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].LengthDelimited;
                m = "string";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BOOL:
                d = value === false;
                m = "bool";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT32:
                m = "uint32";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].DOUBLE:
                t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].Bit64;
                m = "double";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FLOAT:
                t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].Bit32;
                m = "float";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT64:
                d = i || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"].from(value).isZero();
                m = "int64";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].UINT64:
                d = i || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbULong"].from(value).isZero();
                m = "uint64";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED64:
                d = i || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbULong"].from(value).isZero();
                t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].Bit64;
                m = "fixed64";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BYTES:
                d = i || !value.byteLength;
                t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].LengthDelimited;
                m = "bytes";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].FIXED32:
                t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].Bit32;
                m = "fixed32";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED32:
                t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].Bit32;
                m = "sfixed32";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SFIXED64:
                d = i || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"].from(value).isZero();
                t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].Bit64;
                m = "sfixed64";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT32:
                m = "sint32";
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].SINT64:
                d = i || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"].from(value).isZero();
                m = "sint64";
                break;
        }
        return [
            t,
            m,
            i || d
        ];
    }
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "reflectionCreate",
    ()=>reflectionCreate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$scalar$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$message$2d$type$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js [app-client] (ecmascript)");
;
;
function reflectionCreate(type) {
    /**
     * This ternary can be removed in the next major version.
     * The `Object.create()` code path utilizes a new `messagePrototype`
     * property on the `IMessageType` which has this same `MESSAGE_TYPE`
     * non-enumerable property on it. Doing it this way means that we only
     * pay the cost of `Object.defineProperty()` once per `IMessageType`
     * class of once per "instance". The falsy code path is only provided
     * for backwards compatibility in cases where the runtime library is
     * updated without also updating the generated code.
     */ const msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$message$2d$type$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MESSAGE_TYPE"], {
        value: type
    });
    for (let field of type.fields){
        let name = field.localName;
        if (field.opt) continue;
        if (field.oneof) msg[field.oneof] = {
            oneofKind: undefined
        };
        else if (field.repeat) msg[name] = [];
        else switch(field.kind){
            case "scalar":
                msg[name] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$scalar$2d$default$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionScalarDefault"])(field.T, field.L);
                break;
            case "enum":
                // we require 0 to be default value for all enums
                msg[name] = 0;
                break;
            case "map":
                msg[name] = {};
                break;
        }
    }
    return msg;
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Copy partial data into the target message.
 *
 * If a singular scalar or enum field is present in the source, it
 * replaces the field in the target.
 *
 * If a singular message field is present in the source, it is merged
 * with the target field by calling mergePartial() of the responsible
 * message type.
 *
 * If a repeated field is present in the source, its values replace
 * all values in the target array, removing extraneous values.
 * Repeated message fields are copied, not merged.
 *
 * If a map field is present in the source, entries are added to the
 * target map, replacing entries with the same key. Entries that only
 * exist in the target remain. Entries with message values are copied,
 * not merged.
 *
 * Note that this function differs from protobuf merge semantics,
 * which appends repeated fields.
 */ __turbopack_context__.s([
    "reflectionMergePartial",
    ()=>reflectionMergePartial
]);
function reflectionMergePartial(info, target, source) {
    let fieldValue, input = source, output; // where we want our field value to go
    for (let field of info.fields){
        let name = field.localName;
        if (field.oneof) {
            const group = input[field.oneof]; // this is the oneof`s group in the source
            if ((group === null || group === void 0 ? void 0 : group.oneofKind) == undefined) {
                continue; // we skip this field, and all other members too
            }
            fieldValue = group[name]; // our value comes from the the oneof group of the source
            output = target[field.oneof]; // and our output is the oneof group of the target
            output.oneofKind = group.oneofKind; // always update discriminator
            if (fieldValue == undefined) {
                delete output[name]; // remove any existing value
                continue; // skip further work on field
            }
        } else {
            fieldValue = input[name]; // we are using the source directly
            output = target; // we want our field value to go directly into the target
            if (fieldValue == undefined) {
                continue; // skip further work on field, existing value is used as is
            }
        }
        if (field.repeat) output[name].length = fieldValue.length; // resize target array to match source array
        // now we just work with `fieldValue` and `output` to merge the value
        switch(field.kind){
            case "scalar":
            case "enum":
                if (field.repeat) for(let i = 0; i < fieldValue.length; i++)output[name][i] = fieldValue[i]; // not a reference type
                else output[name] = fieldValue; // not a reference type
                break;
            case "message":
                let T = field.T();
                if (field.repeat) for(let i = 0; i < fieldValue.length; i++)output[name][i] = T.create(fieldValue[i]);
                else if (output[name] === undefined) output[name] = T.create(fieldValue); // nothing to merge with
                else T.mergePartial(output[name], fieldValue);
                break;
            case "map":
                // Map and repeated fields are simply overwritten, not appended or merged
                switch(field.V.kind){
                    case "scalar":
                    case "enum":
                        Object.assign(output[name], fieldValue); // elements are not reference types
                        break;
                    case "message":
                        let T1 = field.V.T();
                        for (let k of Object.keys(fieldValue))output[name][k] = T1.create(fieldValue[k]);
                        break;
                }
                break;
        }
    }
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "jsonReadOptions",
    ()=>jsonReadOptions,
    "jsonWriteOptions",
    ()=>jsonWriteOptions,
    "mergeJsonOptions",
    ()=>mergeJsonOptions
]);
const defaultsWrite = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0
}, defaultsRead = {
    ignoreUnknownFields: false
};
function jsonReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
function jsonWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
function mergeJsonOptions(a, b) {
    var _a, _b;
    let c = Object.assign(Object.assign({}, a), b);
    c.typeRegistry = [
        ...(_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : [],
        ...(_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : []
    ];
    return c;
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "reflectionEquals",
    ()=>reflectionEquals
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js [app-client] (ecmascript)");
;
function reflectionEquals(info, a, b) {
    if (a === b) return true;
    if (!a || !b) return false;
    for (let field of info.fields){
        let localName = field.localName;
        let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
        let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
        switch(field.kind){
            case "enum":
            case "scalar":
                let t = field.kind == "enum" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32 : field.T;
                if (!(field.repeat ? repeatedPrimitiveEq(t, val_a, val_b) : primitiveEq(t, val_a, val_b))) return false;
                break;
            case "map":
                if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].INT32 : field.V.T, objectValues(val_a), objectValues(val_b)))) return false;
                break;
            case "message":
                let T = field.T();
                if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b))) return false;
                break;
        }
    }
    return true;
}
const objectValues = Object.values;
function primitiveEq(type, a, b) {
    if (a === b) return true;
    if (type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ScalarType"].BYTES) return false;
    let ba = a;
    let bb = b;
    if (ba.length !== bb.length) return false;
    for(let i = 0; i < ba.length; i++)if (ba[i] != bb[i]) return false;
    return true;
}
function repeatedPrimitiveEq(type, a, b) {
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; i++)if (!primitiveEq(type, a[i], b[i])) return false;
    return true;
}
function repeatedMsgEq(type, a, b) {
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; i++)if (!type.equals(a[i], b[i])) return false;
    return true;
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BinaryWriter",
    ()=>BinaryWriter,
    "binaryWriteOptions",
    ()=>binaryWriteOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/assert.js [app-client] (ecmascript)");
;
;
;
const defaultsWrite = {
    writeUnknownFields: true,
    writerFactory: ()=>new BinaryWriter()
};
function binaryWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
class BinaryWriter {
    constructor(textEncoder){
        /**
         * Previous fork states.
         */ this.stack = [];
        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
        this.chunks = [];
        this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */ finish() {
        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer
        let len = 0;
        for(let i = 0; i < this.chunks.length; i++)len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for(let i = 0; i < this.chunks.length; i++){
            bytes.set(this.chunks[i], offset);
            offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */ fork() {
        this.stack.push({
            chunks: this.chunks,
            buf: this.buf
        });
        this.chunks = [];
        this.buf = [];
        return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */ join() {
        // get chunk of fork
        let chunk = this.finish();
        // restore previous state
        let prev = this.stack.pop();
        if (!prev) throw new Error('invalid state, fork stack empty');
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        // write length of chunk as varint
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */ tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */ raw(chunk) {
        if (this.buf.length) {
            this.chunks.push(new Uint8Array(this.buf));
            this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */ uint32(value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertUInt32"])(value);
        // write value as varint 32, inlined for speed
        while(value > 0x7f){
            this.buf.push(value & 0x7f | 0x80);
            value = value >>> 7;
        }
        this.buf.push(value);
        return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */ int32(value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertInt32"])(value);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["varint32write"])(value, this.buf);
        return this;
    }
    /**
     * Write a `bool` value, a variant.
     */ bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */ bytes(value) {
        this.uint32(value.byteLength); // write length of chunk as varint
        return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */ string(value) {
        let chunk = this.textEncoder.encode(value);
        this.uint32(chunk.byteLength); // write length of chunk as varint
        return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */ float(value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertFloat32"])(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */ double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */ fixed32(value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertUInt32"])(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */ sfixed32(value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertInt32"])(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */ sint32(value) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertInt32"])(value);
        // zigzag encode
        value = (value << 1 ^ value >> 31) >>> 0;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["varint32write"])(value, this.buf);
        return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */ sfixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"].from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */ fixed64(value) {
        let chunk = new Uint8Array(8);
        let view = new DataView(chunk.buffer);
        let long = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbULong"].from(value);
        view.setInt32(0, long.lo, true);
        view.setInt32(4, long.hi, true);
        return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */ int64(value) {
        let long = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"].from(value);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["varint64write"])(long.lo, long.hi, this.buf);
        return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */ sint64(value) {
        let long = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"].from(value), // zigzag encode
        sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi = (long.hi << 1 | long.lo >>> 31) ^ sign;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["varint64write"])(lo, hi, this.buf);
        return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */ uint64(value) {
        let long = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbULong"].from(value);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["varint64write"])(long.lo, long.hi, this.buf);
        return this;
    }
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BinaryReader",
    ()=>BinaryReader,
    "binaryReadOptions",
    ()=>binaryReadOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js [app-client] (ecmascript)");
;
;
;
const defaultsRead = {
    readUnknownField: true,
    readerFactory: (bytes)=>new BinaryReader(bytes)
};
function binaryReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
class BinaryReader {
    constructor(buf, textDecoder){
        this.varint64 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["varint64read"]; // dirty cast for `this`
        /**
         * Read a `uint32` field, an unsigned 32 bit varint.
         */ this.uint32 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$goog$2d$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["varint32read"]; // dirty cast for `this` and access to protected `buf`
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
            fatal: true,
            ignoreBOM: true
        });
    }
    /**
     * Reads a tag - field number and wire type.
     */ tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [
            fieldNo,
            wireType
        ];
    }
    /**
     * Skip one element on the wire and return the skipped data.
     * Supports WireType.StartGroup since v2.0.0-alpha.23.
     */ skip(wireType) {
        let start = this.pos;
        // noinspection FallThroughInSwitchStatementJS
        switch(wireType){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].Varint:
                while(this.buf[this.pos++] & 0x80){
                // ignore
                }
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].Bit64:
                this.pos += 4;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].Bit32:
                this.pos += 4;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].LengthDelimited:
                let len = this.uint32();
                this.pos += len;
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].StartGroup:
                // From descriptor.proto: Group type is deprecated, not supported in proto3.
                // But we must still be able to parse and treat as unknown.
                let t;
                while((t = this.tag()[1]) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WireType"].EndGroup){
                    this.skip(t);
                }
                break;
            default:
                throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */ assertBounds() {
        if (this.pos > this.len) throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */ int32() {
        return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */ sint32() {
        let zze = this.uint32();
        // decode zigzag
        return zze >>> 1 ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */ int64() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"](...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */ uint64() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbULong"](...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */ sint64() {
        let [lo, hi] = this.varint64();
        // decode zig zag
        let s = -(lo & 1);
        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
        hi = hi >>> 1 ^ s;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"](lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */ bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */ fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */ sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */ fixed64() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbULong"](this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */ sfixed64() {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$pb$2d$long$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PbLong"](this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */ float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */ double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */ bytes() {
        let len = this.uint32();
        let start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */ string() {
        return this.textDecoder.decode(this.bytes());
    }
}
}),
"[project]/node_modules/@protobuf-ts/runtime/build/es2015/message-type.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MessageType",
    ()=>MessageType
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$message$2d$type$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$type$2d$check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$json$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$json$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$binary$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$binary$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$create$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$merge$2d$partial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$json$2d$typings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$json$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
const messageTypeDescriptor = baseDescriptors[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$message$2d$type$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MESSAGE_TYPE"]] = {};
class MessageType {
    constructor(name, fields, options){
        this.defaultCheckDepth = 16;
        this.typeName = name;
        this.fields = fields.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeFieldInfo"]);
        this.options = options !== null && options !== void 0 ? options : {};
        messageTypeDescriptor.value = this;
        this.messagePrototype = Object.create(null, baseDescriptors);
        this.refTypeCheck = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$type$2d$check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ReflectionTypeCheck"](this);
        this.refJsonReader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$json$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ReflectionJsonReader"](this);
        this.refJsonWriter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$json$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ReflectionJsonWriter"](this);
        this.refBinReader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$binary$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ReflectionBinaryReader"](this);
        this.refBinWriter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$binary$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ReflectionBinaryWriter"](this);
    }
    create(value) {
        let message = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$create$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionCreate"])(this);
        if (value !== undefined) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$merge$2d$partial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionMergePartial"])(this, message, value);
        }
        return message;
    }
    /**
     * Clone the message.
     *
     * Unknown fields are discarded.
     */ clone(message) {
        let copy = this.create();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$merge$2d$partial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionMergePartial"])(this, copy, message);
        return copy;
    }
    /**
     * Determines whether two message of the same type have the same field values.
     * Checks for deep equality, traversing repeated fields, oneof groups, maps
     * and messages recursively.
     * Will also return true if both messages are `undefined`.
     */ equals(a, b) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionEquals"])(this, a, b);
    }
    /**
     * Is the given value assignable to our message type
     * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */ is(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, false);
    }
    /**
     * Is the given value assignable to our message type,
     * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
     */ isAssignable(arg, depth = this.defaultCheckDepth) {
        return this.refTypeCheck.is(arg, depth, true);
    }
    /**
     * Copy partial data into the target message.
     */ mergePartial(target, source) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$reflection$2d$merge$2d$partial$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reflectionMergePartial"])(this, target, source);
    }
    /**
     * Create a new message from binary format.
     */ fromBinary(data, options) {
        let opt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["binaryReadOptions"])(options);
        return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
    }
    /**
     * Read a new message from a JSON value.
     */ fromJson(json, options) {
        return this.internalJsonRead(json, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$json$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonReadOptions"])(options));
    }
    /**
     * Read a new message from a JSON string.
     * This is equivalent to `T.fromJson(JSON.parse(json))`.
     */ fromJsonString(json, options) {
        let value = JSON.parse(json);
        return this.fromJson(value, options);
    }
    /**
     * Write the message to canonical JSON value.
     */ toJson(message, options) {
        return this.internalJsonWrite(message, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$json$2d$format$2d$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonWriteOptions"])(options));
    }
    /**
     * Convert the message to canonical JSON string.
     * This is equivalent to `JSON.stringify(T.toJson(t))`
     */ toJsonString(message, options) {
        var _a;
        let value = this.toJson(message, options);
        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Write the message to binary format.
     */ toBinary(message, options) {
        let opt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$binary$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["binaryWriteOptions"])(options);
        return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
    }
    /**
     * This is an internal method. If you just want to read a message from
     * JSON, use `fromJson()` or `fromJsonString()`.
     *
     * Reads JSON value and merges the fields into the target
     * according to protobuf rules. If the target is omitted,
     * a new instance is created first.
     */ internalJsonRead(json, options, target) {
        if (json !== null && typeof json == "object" && !Array.isArray(json)) {
            let message = target !== null && target !== void 0 ? target : this.create();
            this.refJsonReader.read(json, message, options);
            return message;
        }
        throw new Error(`Unable to parse message ${this.typeName} from JSON ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$protobuf$2d$ts$2f$runtime$2f$build$2f$es2015$2f$json$2d$typings$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["typeofJsonValue"])(json)}.`);
    }
    /**
     * This is an internal method. If you just want to write a message
     * to JSON, use `toJson()` or `toJsonString().
     *
     * Writes JSON value and returns it.
     */ internalJsonWrite(message, options) {
        return this.refJsonWriter.write(message, options);
    }
    /**
     * This is an internal method. If you just want to write a message
     * in binary format, use `toBinary()`.
     *
     * Serializes the message in binary format and appends it to the given
     * writer. Returns passed writer.
     */ internalBinaryWrite(message, writer, options) {
        this.refBinWriter.write(message, writer, options);
        return writer;
    }
    /**
     * This is an internal method. If you just want to read a message from
     * binary data, use `fromBinary()`.
     *
     * Reads data from binary format and merges the fields into
     * the target according to protobuf rules. If the target is
     * omitted, a new instance is created first.
     */ internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create();
        this.refBinReader.read(reader, message, options, length);
        return message;
    }
}
}),
]);

//# sourceMappingURL=node_modules_%40protobuf-ts_runtime_build_es2015_710ced4f._.js.map